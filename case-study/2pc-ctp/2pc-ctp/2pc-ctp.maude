---(
2PC-CTP
quantitative model, origin apmaude
CTP not send unknown
2024.3.20
)
load ../apmaude
load ../sampler

mod INTERFACE-2PC-CTP is
  inc APMAUDE .
  pr NAT .
  pr SAMPLER .

  sorts TxnState TxnStates .
  subsort TxnState < TxnStates .
  op nullTS : -> TxnState .
  op _;_ : TxnStates TxnStates -> TxnStates [assoc prec 30 id: nullTS] .
  
  --- Nat: txn id.
  sort Phase .
  ops Preparing Committing Committed Aborting Aborted : -> Phase [ctor] .
  op _--_ : Phase Nat -> TxnState [prec 20] .
  op txnStateRecord :_ : TxnStates -> Attribute [ctor] .

  op TriggerTxn : -> Content [ctor] .
  ops Prepare Commit Abort PreYes PreNo Ack : Nat -> Content [ctor] .
  --- CTP msg
  ops PreTimeout DecideQuery DecideReplyCommit DecideReplyAbort DecideReplyUnknown : Nat -> Content [ctor] .

  op TimeoutValue : -> Float .
  eq TimeoutValue = 1.0 .

  op txnTerminal : -> Nat .
  eq txnTerminal = 10 .

  op cohortYesRate : -> Float .
  eq cohortYesRate = 0.9 .

  op d : -> Float .  --- message delay
  eq d = sampleLogNormal(0.0, 1.0) .

  eq pd = sampleLogNormal(0.0, 1.0) .
  eq LIMIT = 200.0 .
endm 

mod COORDINATOR is 
  pr INTERFACE-2PC-CTP .
  op Coord : -> ActorType [ctor] .
  op coord : -> Address [ctor] .

  op txnIdIter :_ : Nat -> Attribute [ctor] .
  op cohorts :_ : AddressList -> Attribute [ctor] .

  sorts TxnReply TxnReplies .
  op _--_ : Address Content -> TxnReply .
  subsort TxnReply < TxnReplies .
  op nullTR : -> TxnReply .
  op _;_ : TxnReplies TxnReplies -> TxnReplies [assoc id: nullTR] .
  op txnReplyRecord :_ : TxnReplies -> Attribute [ctor] .

  vars O O2 : Address . vars AL AL2 : AddressList .
  var AS AS2 : AttributeSet .
  vars TID N N2 : Nat . var T : Float .
  var AC : ActorConfig .
  var SL : ScheduleList .
  var TS : TxnStates . vars TR TR2 : TxnReplies .
  --- start a new txn, send prepare
  crl [prepare] : 
    {T, (TriggerTxn from O to O)}
    < O : Coord | txnIdIter : TID, cohorts : AL, txnStateRecord : TS, AS > 
  => 
    < O : Coord | txnIdIter : TID, cohorts : AL, 
      txnStateRecord : (TS ; (Preparing -- TID)), AS >
    propagate Prepare(TID) from O to AL
  if TID < txnTerminal .
  crl [prepare-terminate] : 
    {T, (TriggerTxn from O to O)}
    < O : Coord | txnIdIter : TID, cohorts : AL, txnStateRecord : TS, AS > 
  => 
    < O : Coord | txnIdIter : TID, cohorts : AL, 
      txnStateRecord : TS, AS >
  if TID >= txnTerminal .
  --- count a yes vote 
  rl [recv-yes] : 
    {T, (PreYes(TID) from O2 to O)}
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, AS >
  => 
    < O : Coord | txnIdIter : TID, txnReplyRecord : (TR ; O2 -- PreYes(TID)), AS > .
  --- rollback if no is received
  rl [recv-no] : 
    {T, (PreNo(TID) from O2 to O)}
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, AS >
  => 
    < O : Coord | txnIdIter : TID, txnReplyRecord : (TR ; O2 -- PreNo(TID)), AS > .

  crl [start-committing] :
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Preparing -- TID), AS >
  =>
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Committing -- TID), AS >
    propagate Commit(TID) from O to AL
  if isAllReply(TR,TID,AL) and canCommit(TR,TID,AL) .

  ceq eagerEnabled(< O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Preparing -- TID), AS > AC) = true 
  if isAllReply(TR,TID,AL) and canCommit(TR,TID,AL) .

  crl [start-aborting] :
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Preparing -- TID), AS >
  =>
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Aborting -- TID), AS >
    propagate Abort(TID) from O to AL
  if isAllReply(TR,TID,AL) and not canCommit(TR,TID,AL) .

  ceq eagerEnabled(< O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Preparing -- TID), AS > AC) = true 
  if isAllReply(TR,TID,AL) and not canCommit(TR,TID,AL) .

  op canCommit : TxnReplies Nat AddressList -> Bool .
  eq canCommit((TR ; (O -- PreYes(TID)) ; TR2),TID,(AL ; O ; AL2)) = 
    canCommit((TR ; TR2),TID,(AL ; AL2)) [owise] .
  eq canCommit(TR,TID,nilAL) = true .
  eq canCommit((TR ; (O -- PreNo(TID)) ; TR2),TID,(AL ; O ; AL2)) = false .
    
  op isAllReply : TxnReplies Nat AddressList -> Bool .
  eq isAllReply((TR ; (O -- PreYes(TID)) ; TR2),TID,(AL ; O ; AL2)) = 
    isAllReply((TR ; TR2),TID,(AL ; AL2)) .
  eq isAllReply((TR ; (O -- PreNo(TID)) ; TR2),TID,(AL ; O ; AL2)) = 
    isAllReply((TR ; TR2),TID,(AL ; AL2)) .
  eq isAllReply(TR,TID,nilAL) = true .
  eq isAllReply(TR,TID,AL) = false [owise] .

  rl [recv-ack] : 
    {T, (Ack(TID) from O2 to O)}
    < O : Coord | txnReplyRecord : TR, AS >
  => 
    < O : Coord | txnReplyRecord : (TR ; O2 -- Ack(TID)), AS > .
  
  crl [commit] :
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Committing -- TID), AS >
    < scheduler : Scheduler | clock : T, AS2 >
  =>
    < O : Coord | txnIdIter : (TID + 1), txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Committed -- TID), AS >
    < scheduler : Scheduler | clock : T, AS2 >
    [0.0, (TriggerTxn from O to O)]
  if isAllAck(TR,TID,AL) .

  ceq eagerEnabled(< O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Committing -- TID), AS > AC) = true 
  if isAllAck(TR,TID,AL) .

  crl [abort] :
    < O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Aborting -- TID), AS >
    < scheduler : Scheduler | clock : T, AS2 >
  =>
    < O : Coord | txnIdIter : (TID + 1), txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Aborted -- TID), AS >
    < scheduler : Scheduler | clock : T, AS2 >
    [0.0, (TriggerTxn from O to O)]
  if isAllAck(TR,TID,AL) .

  ceq eagerEnabled(< O : Coord | txnIdIter : TID, txnReplyRecord : TR, 
      cohorts : AL, txnStateRecord : (TS ; Aborting -- TID), AS > AC) = true
  if isAllAck(TR,TID,AL) .
  
  op isAllAck : TxnReplies Nat AddressList -> Bool .
  eq isAllAck((TR ; (O -- Ack(TID)) ; TR2),TID,(AL ; O ; AL2)) = 
    isAllAck((TR ; TR2),TID,(AL ; AL2)) .
  eq isAllAck(TR,TID,nilAL) = true .
  eq isAllAck(TR,TID,AL) = false [owise] .
endm

mod COHORT is
  pr INTERFACE-2PC-CTP .
  inc COORDINATOR .
  op Cohort : -> ActorType [ctor] .
  op cohort : Nat -> Address [ctor] .

  op neighbour :_ : AddressList -> Attribute [ctor] .
  op waitQuery :_ : TxnReplies -> Attribute [ctor] .

  vars O O2 : Address . vars AL AL2 : AddressList .
  var AS AS2 : AttributeSet .
  vars N N2 : Nat . vars T M : Float .
  var AC : ActorConfig .
  var SL : ScheduleList . var AM : ActiveMsg .
  vars TS TS2 TS3 : TxnStates . var P : Phase .
  var TR : TxnReplies . var TXR : TxnReply . var CO : Content .
  --- either vote yes or no
  rl [reply] : 
    {T, (Prepare(N) from O2 to O)}
    < O : Cohort | txnStateRecord : TS, AS >
   => 
    < O : Cohort | txnStateRecord : (TS ; Preparing -- N), AS >
    [TimeoutValue, PreTimeout(N) from O to O]
    if rand <= cohortYesRate then 
      [d, PreYes(N) from O to O2]
    else 
      [d, PreNo(N) from O to O2]
    fi .

  rl [ack-commit] : 
    {T, (Commit(N) from O2 to O)} 
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), waitQuery : TR, AS >
  => 
    < O : Cohort | txnStateRecord : (TS ; Committed -- N ; TS3), waitQuery : TR, AS >
    [d, Ack(N) from O to O2] ReplyWaitQuery(TR,Commit(N),O) .
  rl [ack-abort] : 
    {T, (Abort(N) from O2 to O)} 
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), waitQuery : TR, AS >
  => 
    < O : Cohort | txnStateRecord : (TS ; Aborted -- N ; TS3), waitQuery : TR, AS >
    [d, Ack(N) from O to O2] ReplyWaitQuery(TR,Abort(N),O) .

  --- ReplyWaitQuery(waitQuery, content(txnid), srcAddress)
  op ReplyWaitQuery : TxnReplies Content Address -> Config .
  eq ReplyWaitQuery((TR ; O2 -- DecideQuery(N)), Commit(N), O) 
    = [d, DecideReplyCommit(N) from O to O2] ReplyWaitQuery(TR,Commit(N),O) .
  eq ReplyWaitQuery((TR ; O2 -- DecideQuery(N)), Abort(N), O) 
    = [d, DecideReplyAbort(N) from O to O2] ReplyWaitQuery(TR,Abort(N),O) .
  --- eq ReplyWaitQuery((TR ; TXR), CO, O) = ReplyWaitQuery(TR, CO, O) [owise] .
  ceq ReplyWaitQuery((TR ; O2 -- DecideQuery(N)), Commit(N2), O) 
    = ReplyWaitQuery(TR, Commit(N2), O) if N =/= N2 [owise] .
  ceq ReplyWaitQuery((TR ; O2 -- DecideQuery(N)), Abort(N2), O) 
    = ReplyWaitQuery(TR, Abort(N2), O) if N =/= N2 [owise] .
  eq ReplyWaitQuery(nullTR, CO, O) = null [owise] .

  --- CTP
  rl [decide-query] :
    {T, PreTimeout(N) from O to O}
    < O : Cohort | txnStateRecord : (TS ; (Preparing -- N) ; TS3), neighbour : AL, AS >
  =>
    < O : Cohort | txnStateRecord : (TS ; (Preparing -- N) ; TS3), neighbour : AL, AS >
    propagate DecideQuery(N) from O to AL .
  crl [decide-queried] :
    {T, PreTimeout(N) from O to O}
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), neighbour : AL, AS >
  =>
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), neighbour : AL, AS >
  if P == Committed or P == Aborted .
  rl [reply-query] :
    {T, DecideQuery(N) from O2 to O}
    < O : Cohort | txnStateRecord : TS, waitQuery : TR, AS >
  => 
    < O : Cohort | txnStateRecord : TS, 
      waitQuery : (TR ; replyQueryWait(TS,{T, DecideQuery(N) from O2 to O})), AS >
    replyQuery(TS,{T, DecideQuery(N) from O2 to O}) .

  --- replyQuery(TxnStates, Current AM)
  op replyQuery : TxnStates ActiveMsg -> Config .
  eq replyQuery(TS,AM) = null [owise] .
  eq replyQuery((TS ; Committed -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = [d, DecideReplyCommit(N) from O to O2] .
  eq replyQuery((TS ; Aborted -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = [d, DecideReplyAbort(N) from O to O2] .
  eq replyQuery((TS ; Preparing -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = null .
  
  --- replyQueryWait(TxnStates,  Current AM)
  op replyQueryWait : TxnStates ActiveMsg -> TxnReplies .
  eq replyQueryWait(TS,{T, DecideQuery(N) from O2 to O}) 
    = (O2 -- DecideQuery(N)) [owise] .
  eq replyQueryWait((TS ; Committed -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = nullTR .
  eq replyQueryWait((TS ; Aborted -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = nullTR .
  eq replyQueryWait((TS ; Preparing -- N ; TS3), {T, DecideQuery(N) from O2 to O}) 
    = (O2 -- DecideQuery(N)) .
  
  crl [recv-query-commit] :
    {T, DecideReplyCommit(N) from O2 to O}
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), AS >
  =>
    < O : Cohort | txnStateRecord : (TS ; Committed -- N ; TS3), AS >
    [d, (Ack(N) from O to coord)]
  if P == Preparing or P == Committed .
  crl [recv-query-abort] :
    {T, DecideReplyAbort(N) from O2 to O}
    < O : Cohort | txnStateRecord : (TS ; P -- N ; TS3), AS >
  =>
    < O : Cohort | txnStateRecord : (TS ; Aborted -- N ; TS3), AS >
    [d, (Ack(N) from O to coord)]
  if P == Preparing or P == Aborted .

endm

mod 2PC-CTP is
  pr COHORT .
  pr COORDINATOR .

endm

set clear rules off .