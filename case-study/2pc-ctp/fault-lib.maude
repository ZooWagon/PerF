---(
library for fault
based on apfmaude for fault-lib
1. fault interface
2. fault modules: msgloss, msgdup, partition, crash, delay, equivocation, tempering
3. fault combine module
4. fault-lib module for be imported
define AddressSetF, AddressListF, QidListF for fauli-lib
2024.3.20
)
load apfmaude
load sampler

mod FAULT-INTERFACE is
  inc APFMAUDE .
  pr SAMPLER .
  --- Fault Injector
  op Injector : -> ActorType .
  op injector : -> Address .
  op injectorObj : -> ActorConfig .

  sorts FaultType FaultList .
  ops nullFault cr de ec tp : -> FaultType [ctor] .
  subsort FaultType < FaultList .
  op nilFL : -> FaultList .
  op _::_ : FaultList FaultList -> FaultList [assoc id: nilFL] .
  
  op faultRegister : -> FaultList  .

  sorts FaultRuleName FaultFlag .
  subsort FaultFlag < Config .
  op nullFRN : -> FaultRuleName .
  op faultEnable : FaultRuleName -> FaultFlag [ctor] .
  op faultPriority : FaultRuleName -> Nat [ctor] .   
  eq faultPriority(nullFRN) = 9999 .
---( priority
  1. less nat has higher priority
  2. recommended priority:
      time-directed : 12
      msg-modified/faded : 33
      msg-dependent : 65
)
  
  vars U1 U2 U FS : Nat .
  --- fault signal for each fault
  op faultSignal : FaultType -> Nat .
  eq faultSignal(nullFault) = 1 .
  --- Message index of fault undergo
  op faultUndergo : Nat Nat -> Nat .
  eq faultUndergo(U1,U2) = U1 * U2 .
  --- isUndergoFault(U1,FS) : is U undergo the fault with signal FS ?
  op isUndergoFault : Nat Nat -> Bool .
  eq isUndergoFault(U,FS) = (U rem FS == 0) .

  --- Bool List
  sort BoolList .
  subsort Bool < BoolList .
  op nilBL : -> BoolList .
  op _::_ : BoolList BoolList -> BoolList [assoc id: nilBL].

  --- Content List
  sort ContentList .
  subsort Content < ContentList .
  op nilCL : -> ContentList .
  op _::_ : ContentList ContentList -> ContentList [assoc id: nilCL] .

  --- FaultRuleName List
  sort FaultRuleNameList .
  subsort FaultRuleName < FaultRuleNameList .
  op nilFRNL : -> FaultRuleNameList .
  op _::_ : FaultRuleNameList FaultRuleNameList -> FaultRuleNameList [assoc id: nilFRNL].

  --- Qid List
  inc QID .
  sort QidListF .
  subsort Qid < QidListF .
  op nilQLF : -> QidListF .
  op _^:^_ : QidListF QidListF -> QidListF [assoc id: nilQLF] .

  --- mark rule label on ScheduleMsg and init faultUndergo as faultSignal(nullFault)
  op MarkRuleLabel : Qid Config -> Config . 
  var Q : Qid . var T : Float . var MSG : Msg . var C : Config . var ACTOR : Actor .
  eq MarkRuleLabel(Q,([T,MSG] C)) =
    [T,MSG,Q,faultSignal(nullFault)] MarkRuleLabel(Q,C) .
  eq MarkRuleLabel(Q,([T,MSG,Q,faultSignal(nullFault)] C)) =
    [T,MSG,Q,faultSignal(nullFault)] MarkRuleLabel(Q,C) .
  eq MarkRuleLabel(Q,(ACTOR C)) =
    ACTOR MarkRuleLabel(Q,C) .
  eq MarkRuleLabel(Q,null) = null .

  vars O O2 : Address . vars AL AL2 : AddressListF .
  vars QL QL2 : QidListF .
  op isVulnerableRl : Qid QidListF -> Bool .
  eq isVulnerableRl(Q,(QL ^:^ Q ^:^ QL2)) = true .
  eq isVulnerableRl(Q,QL) = false [owise] .
  op isVulnerableAddress : Address AddressListF -> Bool .
  eq isVulnerableAddress(O, (AL  ^:^  O  ^:^  AL2)) = true .
  eq isVulnerableAddress(O, nilALF) = true .   --- all address are vulnerable if not direct
  eq isVulnerableAddress(O,AL) = false [owise] .

endm


mod FAULT-MSGLOSS is
  inc FAULT-INTERFACE .
  --- abbr. ml . signal: 2
  op msgloss : -> Address .
  op ml : -> FaultType .
  eq faultSignal(ml) = 2 .

  --- lost msg
  op MLeatMsg :_ : ScheduleList -> Attribute [ctor] .
  --- rate for doing ml-vul, set by initconf, default 1.0
  op MLfaultRate :_ : Float -> Attribute [ctor] .
  --- the recvers in list may suffer from msg loss
  op MLvulnerableRecv :_ : AddressListF -> Attribute [ctor] .
  --- the src in list may suffer from msg loss
  op MLvulnerableSrc :_ : AddressListF -> Attribute [ctor] .
  --- the rule label in list may suffer from msg loss
  op MLvulnerableRl :_ : QidListF -> Attribute [ctor] .

  var SL : ScheduleList . var MSG : Msg .
  var AS : AttributeSet . var T : Float .
  var Q : Qid . var FU : Nat .
  
  --- func: a msg may lose if msg rl is in MLvulnerableRl 
  --- *and* msg recv is in MLvulnerableRecv 
  --- *and* msg src is in MLvulnerableSrc
  op ml-vul : -> FaultRuleName .
  eq faultPriority(ml-vul) = 33 .   --- msg-faded
  rl [msgloss-vulnerable] :
    FR([T, MSG, Q, FU])
    faultEnable(ml-vul)
    < msgloss : Injector | MLeatMsg : SL, AS >
  =>
    < msgloss : Injector | 
      MLeatMsg : (SL ; [T, MSG, Q, faultUndergo(FU,faultSignal(ml))]), AS > .

  vars O O2 : Address . vars AL AL2 : AddressListF .
  vars QL QL2 : QidListF . vars M R : Float .
  --- isEnableML-vul(mood, loss rate, msg rl, vul rl, msg src, vul src, msg recv, vul recv)
  op isEnableML-vul : Float Float Qid QidListF Address AddressListF Address AddressListF -> Bool .
  eq isEnableML-vul(M,R,Q,QL,O,AL,O2,AL2) =
    (M <= R) 
    and isVulnerableRl(Q,QL) 
    and isVulnerableAddress(O,AL)
    and isVulnerableAddress(O2,AL2) .
  eq isEnableML-vul(M,R,Q,QL,O,AL,O2,AL2) = false [owise] .

endm

mod FAULT-MSGDUP is
  inc FAULT-INTERFACE .
  --- abbr. md . signal: 3
  op msgdup : -> Address .
  op md : -> FaultType .
  eq faultSignal(md) = 3 .
  
  --- duplicated msg
  op MDdupMsg :_ : ScheduleList -> Attribute [ctor] .
  --- rate for doing md-vul, set by initconf, default 1.0
  op MDfaultRate :_ : Float -> Attribute [ctor] .
  --- the rl in list may suffer from msg dup
  op MDvulnerableRl :_ : QidListF -> Attribute [ctor] .
  --- the recvers in list may suffer from msg dup
  op MDvulnerableRecv :_ : AddressListF -> Attribute [ctor] .
  --- the src in list may suffer from msg dup
  op MDvulnerableSrc :_ : AddressListF -> Attribute [ctor] .

  var SL : ScheduleList . var MSG : Msg .
  var AS : AttributeSet . var T : Float .
  var Q : Qid . var FU : Nat .

  --- func1: a msg may duplicate if msg rl is in MDvulnerableRl 
  --- *and* msg recv is in MDvulnerableRecv 
  --- *and* msg src is in MDvulnerableSrc
  op md-vul : -> FaultRuleName .
  eq faultPriority(md-vul) = 65 .   --- msg-dependent
  rl [msgdup-vulnerable] :
    FR([T, MSG, Q, FU])
    faultEnable(md-vul)
    < msgdup : Injector | MDdupMsg : SL, AS >
  =>
    < msgdup : Injector | 
      MDdupMsg : (SL ; [T, MSG, Q, faultUndergo(FU,faultSignal(md))]), AS > 
    FP([T, MSG, Q, faultUndergo(FU,faultSignal(md))])
    [pd, MSG, Q, faultUndergo(FU,faultSignal(md))] .

  vars O O2 : Address . vars AL AL2 : AddressListF .
  vars QL QL2 : QidListF . vars M R : Float .
  --- isEnableMD-vul(mood, loss rate, msg rl, vul rl, msg src, vul src, msg recv, vul recv, faultUndergo)
  op isEnableMD-vul : Float Float Qid QidListF Address AddressListF Address AddressListF Nat -> Bool .
  eq isEnableMD-vul(M,R,Q,QL,O,AL,O2,AL2,FU) =
    (M <= R) 
    and isVulnerableRl(Q,QL) 
    and isVulnerableAddress(O,AL)
    and isVulnerableAddress(O2,AL2) 
    and not isUndergoFault(FU,faultSignal(md)) .
  eq isEnableMD-vul(M,R,Q,QL,O,AL,O2,AL2,FU) = false [owise] .
endm

mod FAULT-PARTITION is
  inc FAULT-INTERFACE .
  --- abbr. pa . signal: 5
  op partition : -> Address .
  op pa : -> FaultType .
  eq faultSignal(pa) = 5 .

  sort PAFaultStatus .
  ops standby cutting recovered : -> PAFaultStatus [ctor] .
  sort Partition .
  ops _:|:_ : AddressListF AddressListF -> Partition [ctor] .

  op PAstatus :_ : PAFaultStatus -> Attribute [ctor] .
  op PAallActors :_ : AddressListF -> Attribute [ctor] .
  op PApart :_ : Partition -> Attribute [ctor] .
  op PAcutMsg :_ : ScheduleList -> Attribute [ctor] .
  --- the rl in list may suffer from pa
  op PAvulnerableRl :_ : QidListF -> Attribute [ctor] .
  --- the recvers in list may suffer from pa
  op PAvulnerableRecv :_ : AddressListF -> Attribute [ctor] .
  --- the src in list may suffer from pa
  op PAvulnerableSrc :_ : AddressListF -> Attribute [ctor] .
  --- partition duration time
  op PAdurationTime :_ : Float -> Attribute [ctor] .
  --- partition occur time
  op PAoccurTime :_ : Float -> Attribute [ctor] .


  vars SL SL2 : ScheduleList .
  vars AS1 AS2 : AttributeSet . vars AL1 AL2 AL : AddressListF .
  vars O O1 O2 : Address . var CO : Content . var FS : PAFaultStatus .
  vars T M R R2 TP TO TE : Float . var PA : Partition .
  var FU : Nat . var Q : Qid . vars QL QL2 : QidListF .

  --- func1: make part by time
  op pa-make-t : -> FaultRuleName .
  eq faultPriority(pa-make-t) = 12 .   --- time-directed
  rl [part-make-time] :
    FR([T, (CO from O to O2), Q, FU])
    faultEnable(pa-make-t)
    < partition : Injector | PAstatus : standby,
        PApart : (AL1 :|: AL2), PAallActors : AL, AS1 >
  =>
    < partition : Injector | PAstatus : cutting,
        PApart : 
        if AL1 == nilALF then devideAddresses(AL,0.9,(nilALF :|: nilALF))
        else (AL1 :|: AL2) fi, 
        PAallActors : AL, AS1 >
    FP([T, (CO from O to O2), Q, faultUndergo(FU,faultSignal(pa))]) .
  --- isEnablePA-make-t(PAstatus, PAoccurTime, current time)
  op isEnablePA-make-t : PAFaultStatus Float Float -> Bool .
  eq isEnablePA-make-t(standby,TO,T) = TO <= T .
  eq isEnablePA-make-t(FS,TO,T) = false [owise] .

  --- func2: make part by qid
  op pa-make-rl : -> FaultRuleName .
  eq faultPriority(pa-make-rl) = 65 .   --- msg-dependent
  rl [part-make-rl] :
    FR([T, (CO from O to O2), Q, FU])
    faultEnable(pa-make-rl)
    < partition : Injector | PAstatus : standby, PAoccurTime : TO,
        PApart : (AL1 :|: AL2), PAallActors : AL, AS1 >
  =>
    < partition : Injector | PAstatus : cutting, PAoccurTime : T,
        PApart : 
        if AL1 == nilALF then devideAddresses(AL,0.9,(nilALF :|: nilALF))
        else (AL1 :|: AL2) fi, 
        PAallActors : AL, AS1 >
    FP([T, (CO from O to O2), Q, faultUndergo(FU,faultSignal(pa))]) .
  --- isEnablePA-make-t(PAstatus, msg rl, vul rl, msg src, vul src, msg recv, vul recv)
  op isEnablePA-make-rl : PAFaultStatus Qid QidListF Address AddressListF Address AddressListF -> Bool .
  eq isEnablePA-make-rl(standby,Q,QL,O,AL,O2,AL2) =
    isVulnerableRl(Q,QL) 
    and isVulnerableAddress(O,AL)
    and isVulnerableAddress(O2,AL2) .
  eq isEnablePA-make-rl(FS,Q,QL,O,AL,O2,AL2) = false [owise] .

  op pa-cut : -> FaultRuleName .
  eq faultPriority(pa-cut) = 33 .   --- msg-faded
  rl [part-cut] :
    FR([T, (CO from O to O2), Q, FU])
    faultEnable(pa-cut)
    < partition : Injector | PAstatus : cutting, 
        PAcutMsg : SL2, AS1 >
  => 
    < partition : Injector | PAstatus : cutting, 
        PAcutMsg : (SL2 ; [T, (CO from O to O2), Q, faultUndergo(FU,faultSignal(pa))]),
        AS1 > .
  
  --- isEnablePA-cut(PAstatus, src, recv, part, partEndTtime, curtime
  op isEnablePA-cut : PAFaultStatus Address Address Partition Float Float -> Bool .
  eq isEnablePA-cut(cutting, O1, O2, (AL1 :|: AL2), TE, T)
    = isCut(O1,O2,AL1,AL2) and TE > T .
  eq isEnablePA-cut(cutting, O1, O2, (AL1 :|: AL2), TE, T) = false [owise] .

  op pa-reco-t : -> FaultRuleName .
  eq faultPriority(pa-reco-t) = 12 .   --- time-directed
  rl [part-recover] :
    FR([T, (CO from O to O2), Q, FU])
    faultEnable(pa-reco-t)
    < partition : Injector | PAstatus : cutting,
      PAoccurTime : TO, PAdurationTime : TP, AS1 >
  =>
    < partition : Injector | PAstatus : recovered,
      PAoccurTime : TO, PAdurationTime : TP, AS1 >
    FP([T, (CO from O to O2), Q, faultUndergo(FU,faultSignal(pa))]) .
  --- isEnablePA-reco-t(PAstatus,partEndTime, curtime)
  op isEnablePA-reco-t : PAFaultStatus Float Float -> Bool .
  eq isEnablePA-reco-t(cutting, TE, T) = TE <= T .
  eq isEnablePA-reco-t(FS,TE,T) = false [owise] .

  --- devide Addresses to 2 non-empty Addresses
  --- rew devideAddresses((server ; client(0) ; client(1) ; client(2)),0.9,(empty :|: empty)) .
  op devideAddresses : AddressListF Float Partition -> Partition .
  ceq devideAddresses((O ^:^ AL),R,(AL1 :|: AL2)) = devideAddresses(AL,rand,((O ^:^ AL1) :|: AL2)) 
      if R >= 0.5 [owise] .
  ceq devideAddresses((O ^:^ AL),R,(AL1 :|: AL2)) = devideAddresses(AL,rand,(AL1 :|: (O ^:^ AL2)))
      if R < 0.5 [owise] .
  eq devideAddresses(O,R,(nilALF :|: AL2)) = devideAddresses(nilALF,rand,(O :|: AL2)) .
  eq devideAddresses(O,R,(AL1 :|: nilALF)) = devideAddresses(nilALF,rand,(AL1 :|: O)) .
  eq devideAddresses(nilALF,R,PA) = PA .

  --- if (O1 in AL1 and O2 in AL2) or (O2 in AL1 and O1 in AL2), then true
  op isCut : Address Address AddressListF AddressListF -> Bool [ctor] .
  op isCutRec : Address Address AddressListF AddressListF -> Bool [ctor] .
  eq isCut(O1,O2,AL1,AL2) = 
      (isInAddresses(O1,AL1) and isInAddresses(O2,AL2))
      or (isInAddresses(O1,AL2) and isInAddresses(O2,AL1)) .
  op isInAddresses : Address AddressListF -> Bool [ctor] .
  eq isInAddresses(O1, (AL1 ^:^ O1 ^:^ AL2)) = true .
  eq isInAddresses(O1, AL1) = false [owise] .

endm

---(
mod FAULT-CRASH is
  inc FAULT-INTERFACE .

  vars SL SL2 : ScheduleList . var MSG : Msg .
  vars AS AS1 AS2 : AttributeSet . vars AL1 AL2 : AddressListF .
  vars O O1 O2 : Address . var MP : Content . var FS : CRFaultStatus .
  vars T F M R R2 : Float . vars C C2 : Config . var AT : ActorType . 
  var AC : ActorConfig . var AM : ActiveMsg . 
  var CON : Content . vars CL1 CL2 : ContentList .

  sort CRFaultStatus .
  ops standby crashing rebooted : -> CRFaultStatus [ctor] .
  op CRstatus :_ : CRFaultStatus -> Attribute [ctor] .

  sort DictConfig .
  op _=-=_ : Address Config -> DictConfig [ctor] .
  op null : -> DictConfig .
  op _;_ : DictConfig DictConfig -> DictConfig [assoc comm id: null] .
  --- make Config to DictoryConfig
  op CRmakeDictConfig : Config DictConfig -> DictConfig [ctor] .
  var DC : DictConfig .
  eq CRmakeDictConfig((< O : AT | AS > C),((O =-= C2) ; DC)) = 
      CRmakeDictConfig(C,((O =-= (C2 < O : AT | AS >)) ; DC)) .
  eq CRmakeDictConfig((< O : AT | AS > C),DC) = 
      CRmakeDictConfig(C,((O =-= (< O : AT | AS >)) ; DC)) [owise] .
  eq CRmakeDictConfig(({T, (MP from O2 to O)} C),((O =-= C2) ; DC)) = 
      CRmakeDictConfig(C,((O =-= (C2 {T, (MP from O2 to O)})) ; DC)) .
  eq CRmakeDictConfig(({T, (MP from O2 to O)} C),DC) = 
      CRmakeDictConfig(C,((O =-= {T, (MP from O2 to O)}) ; DC)) [owise] .
  eq CRmakeDictConfig(null,DC) = DC [owise] .

  --- init state snap, for reboot
  op CRinitStore :_ : DictConfig -> Attribute [ctor] .
  --- vulnerable objs, which can crash
  op CRvulnerableObjs :_ : AddressListF -> Attribute [ctor] .
  --- vulnerable content, may cause crash
  op CRvulnerableContent :_ : ContentList -> Attribute [ctor] .
  --- current crashing obj
  op CRcrashingObj :_ : Address -> Attribute [ctor] .
  --- record last crashed obj
  op CRcrashingObjRecord :_ : Address -> Attribute [ctor] .
  --- msgs cut during crash
  op CRcutMsg :_ : ScheduleList -> Attribute [ctor] .
  --- CR mood
  op CRmood :_ : Float -> Attribute [ctor] .
  --- rate for crash, set by initconf
  op CRcrashRate :_ : Float -> Attribute [ctor] .
  --- rate for reboot, set by initconf
  op CRrebootRate :_ : Float -> Attribute [ctor] .

  --- crash an obj
  crl [make-crash] :
    < injector : Injector | CRstatus : standby, CRmood : M, CRcrashRate : R,
      CRvulnerableObjs : AL1, CRcrashingObj : O2, faultFlag : faultLicense(cr), AS1 >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | CRstatus : crashing, CRmood : rand, CRcrashRate : R,
      CRvulnerableObjs : AL1, CRcrashingObj : selectCrushObj(AL1,0.0,rand,nullAddr),
      faultFlag : faultUpdateMood, AS1 >
    AC {T | SL} faultUpdateMood
  if M <= R .
  --- a crashing node can't recv msg, so cut
  crl [cut-crash] :
    < injector : Injector | CRstatus : crashing, CRmood : M, CRrebootRate : R,
      CRcutMsg : SL2, CRcrashingObj : O1,
      faultMsg : { T, (MP from O2 to O1)}, faultFlag : faultLicense(cr), AS1 >
    AC {T | SL} faultTrigger
  => 
    < injector : Injector | CRstatus : crashing, CRmood : rand, CRrebootRate : R,
      CRcutMsg : (SL2 ; [T,(MP from O2 to O1),0]), CRcrashingObj : O1,
      faultMsg : null, faultFlag : faultUpdateMood, AS1 >
    AC {T | SL} faultUpdateMood
  if M > R .
  crl [reboot] :
    < injector : Injector | CRstatus : crashing, CRcrashingObj : O,
      CRmood : M, CRrebootRate : R, CRcrashingObjRecord : O1,
      CRinitStore : ((O =-= C) ; DC), faultMsg : { T, MSG },
      faultFlag : faultLicense(cr), AS1 >
    < O : AT | AS >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | CRstatus : rebooted, CRcrashingObj : nullAddr,
      CRmood : rand, CRrebootRate : R, CRcrashingObjRecord : O,
      CRinitStore : ((O =-= C) ; DC), faultMsg : rebootConfigMsg(C, T),
      faultFlag : faultUpdateMood, AS1 >
    AC rebootConfigActor(C) {T | insert(SL,[T + 2.71828,MSG,0])} faultUpdateMood
  if M <= R .

  --- select crash Obj from vulnerableObjs
  --- selectCrushObj(vulnerableObjs,highestScore,currentScore,crashObj)
  op selectCrushObj : AddressListF Float Float Address -> Address [ctor] .
  ceq selectCrushObj((O ^:^ AL1),R,R2,O2) = selectCrushObj(AL1,R2,rand,O)
    if R2 > R [owise] .
  ceq selectCrushObj((O ^:^ AL1),R,R2,O2) = selectCrushObj(AL1,R,rand,O2)
    if R2 <= R [owise] .
  eq selectCrushObj(nilALF,R,R2,O2) = O2 .

  --- reboot config with actor
  op rebootConfigActor : Config -> Config .
  eq rebootConfigActor(null) = null .
  eq rebootConfigActor({F, MSG}) = null .
  eq rebootConfigActor(AC C) = AC rebootConfigActor(C) [owise] .

  --- reboot config with msg
  op rebootConfigMsg : Config Float -> Config .
  eq rebootConfigMsg(null, T) = null .
  eq rebootConfigMsg({F, MSG}, T) = {T, MSG} .
  eq rebootConfigMsg(AC C, T) = rebootConfigMsg(C,T) [owise] .

  --- whether trigger crash fault
  --- CRnotFault(FaultStatus, mood, crashRate, rebootRate, 
  ---      crashAddress, DstAddress, curContent, vulnerableContentList)
  op CRnotFault : CRFaultStatus Float Float Float Address Address Content ContentList -> Bool [ctor] .
  ceq CRnotFault(standby,M,R,R2,O,O2,CON,CL1) = true if M > R or not CRisContentVulnerable(CON,CL1) .
  ceq CRnotFault(crashing,M,R,R2,O,O2,CON,CL1) = true if M > R2 and O =/= O2 .
  eq CRnotFault(rebooted,M,R,R2,O,O2,CON,CL1) = true .
  eq CRnotFault(FS,M,R,R2,O,O2,CON,CL1) = false [owise] .

  --- whether content is vulnerable
  op CRisContentVulnerable : Content ContentList -> Bool [ctor] .
  eq CRisContentVulnerable(CON, (CL1 :: CON :: CL2)) = true .
  eq CRisContentVulnerable(CON,CL1) = false [owise] .

endm

mod FAULT-DELAY is
  inc FAULT-INTERFACE .
  --- abbr. DE

  op DEmood :_ : Float -> Attribute [ctor] .
  --- delayed msg
  op DEdelayedMsg :_ : ScheduleList -> Attribute [ctor] .
  --- delay time of delayed msg, set by fault input
  op DEtime :_ : Float -> Attribute [ctor] .
  --- rate for doing delay, set by fault input
  op DEfaultRate :_ : Float -> Attribute [ctor] .
  --- the contents in list may suffer from delay
  op DEvulnerableContent :_ : ContentList -> Attribute [ctor] .
  --- the recvers in list may suffer from delay
  op DEvulnerableRecv :_ : AddressListF -> Attribute [ctor] .
  --- the src in list may suffer from delay
  op DEvulnerableSrc :_ : AddressListF -> Attribute [ctor] .
  --- the rule in list may suffer from delay
  op DEvulnerableRule :_ : QidListF -> Attribute [ctor] .

  
---(
  1. arbitrary delay with rate
    may delay if M <= R (rate)
    set DEvulnerableRule : nilQLF
  2. by src and/or recv and/or content with rate
    may delay if src, recv, content are matched
    set DEvulnerableRule : nilQLF
  3. by rule name with rate 1.0
    may delay if rule name are matched
    set DEvulnerableRule : {rule name}
)

  vars SL SL2 : ScheduleList . var MSG : Msg .
  var AS : AttributeSet . vars T M R DT : Float .
  var AC : ActorConfig . vars O O1 O2 : Address .
  var CO : Content . vars CL CL2 : ContentList .
  vars AL AL1 AL2 : AddressListF .
  crl [delay-execute] :
    < injector : Injector | DEmood : M, DEfaultRate : R, 
      DEdelayedMsg : SL2, DEvulnerableContent : CL, 
      DEvulnerableSrc : AL1, DEvulnerableRecv : AL2,
      DEtime : DT,
      faultMsg :{ T, (CO from O to O2) }, 
      faultFlag : faultLicense(de), AS >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | DEmood : rand, DEfaultRate : R,
      DEdelayedMsg : (SL2 ; [T,(CO from O to O2),0]), 
      DEvulnerableContent : CL, 
      DEvulnerableSrc : AL1, DEvulnerableRecv : AL2,
      DEtime : DT,
      faultMsg : null, 
      faultFlag : faultUpdateMood, AS > faultUpdateMood
    AC {T | insert(SL,[T + DT, (CO from O to O2), 0])}
  if M <= R and DEisVulnerable(CO,CL,O,AL1,O2,AL2) .
  crl [delay-absolve] :
    < injector : Injector | DEmood : M, DEfaultRate : R, 
      DEdelayedMsg : SL2, DEvulnerableContent : CL, 
      DEvulnerableSrc : AL1, DEvulnerableRecv : AL2,
      DEtime : DT,
      faultMsg : { T, (CO from O to O2) }, 
      faultFlag : faultLicense(de), AS >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | DEmood : rand, DEfaultRate : R,
      DEdelayedMsg : SL2, DEvulnerableContent : CL, 
      DEvulnerableSrc : AL1, DEvulnerableRecv : AL2,
      DEtime : DT,
      faultMsg : { T, (CO from O to O2) }, 
      faultFlag : faultUpdateMood, AS > faultUpdateMood
    AC {T | SL}
  if M <= R and not DEisVulnerable(CO,CL,O,AL1,O2,AL2) .

  --- DEnotFault(mood,faultRate) = mood > faultRate
  op DEnotFault : Float Float -> Bool [ctor] .
  ceq DEnotFault(M,R) = true if M > R .
  eq DEnotFault(M,R) = false [owise] .

  --- judge whether src, recv, content is vulnerable
  op DEisVulnerable : Content ContentList Address AddressListF Address AddressListF -> Bool .
  eq DEisVulnerable(CO,CL,O1,AL1,O2,AL2) 
    = DEisVulnerableContent(CO,CL) and 
      DEisVulnerableAddress(O1,AL1) and 
      DEisVulnerableAddress(O2,AL2) .
  --- judge whether CO is in CL. If CL is nil, true immediately.
  op DEisVulnerableContent : Content ContentList -> Bool .
  eq DEisVulnerableContent(CO,(CL :: CO :: CL2)) = true .
  eq DEisVulnerableContent(CO,nilCL) = true .
  eq DEisVulnerableContent(CO,CL) = false [owise] .
  --- judge whether O is in AL IF AL is nil, true immediately.
  op DEisVulnerableAddress : Address AddressListF -> Bool .
  eq DEisVulnerableAddress(O, (AL1 ^:^ O ^:^ AL2)) = true .
  eq DEisVulnerableAddress(O, nilALF) = true .
  eq DEisVulnerableAddress(O,AL1) = false [owise] .

endm

mod FAULT-EQUIVOCATION is
  --- abbr. ec
  inc FAULT-INTERFACE .

  --- evil sender
  op ECevilSrc :_ : AddressListF -> Attribute .
  --- equivocate content
  op ECequivocateContent :_ : ContentEquivocatePairList -> Attribute .
  --- suffered msg
  op ECsufferedMsg :_ : ScheduleList -> Attribute .

  sorts ContentEquivocatePair ContentEquivocatePairList .
  subsort ContentEquivocatePair < ContentEquivocatePairList .
  op [_|_,_] : Content Content Nat -> ContentEquivocatePair [ctor] .
  op nilCEPL : -> ContentEquivocatePairList .
  op _::_ : ContentEquivocatePairList ContentEquivocatePairList -> ContentEquivocatePairList [assoc id: nilCEPL] .

  vars CO CO1 CO2 : Content . vars A1 A2 : Address .
  vars AL1 AL2 : AddressListF . vars CEPL1 CEPL2 : ContentEquivocatePairList .
  vars EN : Nat .
  vars SL SL1 SL2 : ScheduleList . var MSG : Msg .
  var AS : AttributeSet . vars T M R DT : Float .
  var AC : ActorConfig .

  rl [equivocate] :
    < injector : Injector | 
      ECsufferedMsg : SL1,
      ECevilSrc : AL1,
      ECequivocateContent : (CEPL1 :: [CO | CO2, EN] :: CEPL2),
      faultMsg :{ T, (CO from A1 to A2) }, 
      faultFlag : faultLicense(ec), AS >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | 
      ECsufferedMsg : (SL1 ; [T, CO from A1 to A2, 0]),
      ECevilSrc : AL1,
      ECequivocateContent : (CEPL1 :: [CO | CO2, sd(EN,1)] :: CEPL2),
      faultMsg :{ T, (CO2 from A1 to A2) }, 
      faultFlag : faultUpdateMood, AS > faultUpdateMood
    AC {T | SL} .

  --- ECnotFault(curMsg, evil sender, equivocate content)
  op ECnotFault : ActiveMsg AddressListF ContentEquivocatePairList -> Bool .
  ceq ECnotFault({T, CO from A1 to A2}, 
    (AL1 ^:^ A1 ^:^ AL2), (CEPL1 :: [CO | CO2, EN] :: CEPL2))
    = false if EN > 0 .
  eq ECnotFault({T, CO from A1 to A2}, AL1, CEPL1) = true [owise] .

endm

mod FAULT-TEMPERING is
  --- abbr. TP
  inc FAULT-INTERFACE .

  --- evil sender
  op TPevilSrc :_ : AddressListF -> Attribute .
  --- temper content
  op TPtemperContent :_ : ContentTemperingPairList -> Attribute .
  --- suffered msg
  op TPsufferedMsg :_ : ScheduleList -> Attribute .

  sorts ContentTemperingPair ContentTemperingPairList .
  subsort ContentTemperingPair < ContentTemperingPairList .
  op [_|_] : Content Content -> ContentTemperingPairList [ctor] .
  op nilCTPL : -> ContentTemperingPairList .
  op _::_ : ContentTemperingPairList ContentTemperingPairList -> ContentTemperingPairList [assoc id: nilCTPL] .

  vars CO CO1 CO2 : Content . vars A1 A2 : Address .
  vars AL1 AL2 : AddressListF . vars CTPL1 CTPL2 : ContentTemperingPairList .
  vars EN : Nat .
  vars SL SL1 SL2 : ScheduleList . var MSG : Msg .
  var AS : AttributeSet . vars T M R DT : Float .
  var AC : ActorConfig .

  rl [tempering] :
    < injector : Injector | 
      TPsufferedMsg : SL1,
      TPevilSrc : AL1,
      TPtemperContent : (CTPL1 :: [CO | CO2] :: CTPL2),
      faultMsg :{ T, (CO from A1 to A2) }, 
      faultFlag : faultLicense(tp), AS >
    AC {T | SL} faultTrigger
  =>
    < injector : Injector | 
      TPsufferedMsg : (SL1 ; [T, CO from A1 to A2, 0]),
      TPevilSrc : AL1,
      TPtemperContent : (CTPL1 :: [CO | CO2] :: CTPL2),
      faultMsg :{ T, (CO2 from A1 to A2) }, 
      faultFlag : faultUpdateMood, AS > faultUpdateMood
    AC {T | SL} .

  --- TPnotFault(curMsg, evil sender, tempering content)
  op TPnotFault : ActiveMsg AddressListF ContentTemperingPairList -> Bool .
  ceq TPnotFault({T, CO from A1 to A2}, 
    (AL1 ^:^ A1 ^:^ AL2), (CTPL1 :: [CO1 | CO2] :: CTPL2))
    = false if CO == CO1 .
  eq TPnotFault({T, CO from A1 to A2}, AL1, CTPL1) = true [owise] .
endm
)
mod FAULT-COMBINE is
  inc APFMAUDE .
  inc FAULT-INTERFACE .
  inc FAULT-MSGLOSS .
  inc FAULT-MSGDUP .
  inc FAULT-PARTITION .
  --- inc FAULT-CRASH .
  --- inc FAULT-DELAY .
  --- inc FAULT-EQUIVOCATION .
  --- inc FAULT-TEMPERING .

  vars SRCA RECVA : Address . var MSGCO : Content . var MSGQID : Qid . var MSGFU : Nat .
  vars T M : Float . vars S : Nat .
  var ML-R : Float . var ML-QL : QidListF . vars ML-AL ML-AL2 : AddressListF . var ML-AS : AttributeSet .
  var MD-R : Float . var MD-QL : QidListF . vars MD-AL MD-AL2 : AddressListF . var MD-AS : AttributeSet .
  vars PA-TO PA-TD : Float . vars PA-P1 PA-P2 PA-ALL : AddressListF . var PA-FS : PAFaultStatus . 
  var PA-QL : QidListF . vars PA-AL PA-AL2 : AddressListF . var PA-AS : AttributeSet .

  op FP : ScheduleMsg Float -> FaultPotentialMsg .
  eq FP([T, (MSGCO from SRCA to RECVA), MSGQID, MSGFU]) = 
    FP([T, (MSGCO from SRCA to RECVA), MSGQID, MSGFU],rand) .

  crl [mediate-enable] :
    FP([T, (MSGCO from SRCA to RECVA), MSGQID, MSGFU], M)
    < msgloss : Injector | MLfaultRate : ML-R, MLvulnerableRl : ML-QL, MLvulnerableRecv : ML-AL, MLvulnerableSrc : ML-AL2, ML-AS >
    < msgdup : Injector | MDfaultRate : MD-R, MDvulnerableRl : MD-QL, MDvulnerableRecv : MD-AL, MDvulnerableSrc : MD-AL2, MD-AS >
    < partition : Injector | PAstatus : PA-FS, PAoccurTime : PA-TO, PAdurationTime : PA-TD, PApart : (PA-P1 :|: PA-P2), 
      PAallActors : PA-ALL, PAvulnerableRl : PA-QL, PAvulnerableRecv : PA-AL, PAvulnerableSrc : PA-AL2, PA-AS >
  =>
    < msgloss : Injector | MLfaultRate : ML-R, MLvulnerableRl : ML-QL, MLvulnerableRecv : ML-AL, MLvulnerableSrc : ML-AL2, ML-AS >
    < msgdup : Injector | MDfaultRate : MD-R, MDvulnerableRl : MD-QL, MDvulnerableRecv : MD-AL, MDvulnerableSrc : MD-AL2, MD-AS >
    < partition : Injector | PAstatus : PA-FS, PAoccurTime : PA-TO, PAdurationTime : PA-TD, PApart : (PA-P1 :|: PA-P2), 
      PAallActors : PA-ALL, PAvulnerableRl : PA-QL, PAvulnerableRecv : PA-AL, PAvulnerableSrc : PA-AL2, PA-AS >
    FR([T, (MSGCO from SRCA to RECVA), MSGQID, MSGFU])
    geneFaultEnable(
        geneFaultRuleReadyList( nullFRN
          :: ml-vul
          :: md-vul
          :: pa-make-t :: pa-make-rl :: pa-cut :: pa-reco-t
          , false
          :: isEnableML-vul(M,ML-R,MSGQID,ML-QL,SRCA,ML-AL2,RECVA,ML-AL)
          :: isEnableMD-vul(M,MD-R,MSGQID,MD-QL,SRCA,MD-AL2,RECVA,MD-AL,MSGFU) 
          :: isEnablePA-make-t(PA-FS,PA-TO,T) 
          :: isEnablePA-make-rl(PA-FS,MSGQID,PA-QL,SRCA,PA-AL2,RECVA,PA-AL)
          :: isEnablePA-cut(PA-FS,SRCA,RECVA,(PA-P1 :|: PA-P2),(PA-TO + PA-TD),T)
          :: isEnablePA-reco-t(PA-FS,(PA-TO + PA-TD),T)
          ))
    if false
      or isEnableML-vul(M,ML-R,MSGQID,ML-QL,SRCA,ML-AL2,RECVA,ML-AL)
      or isEnableMD-vul(M,MD-R,MSGQID,MD-QL,SRCA,MD-AL2,RECVA,MD-AL,MSGFU) 
      or isEnablePA-make-t(PA-FS,PA-TO,T) 
      or isEnablePA-make-rl(PA-FS,MSGQID,PA-QL,SRCA,PA-AL2,RECVA,PA-AL)
      or isEnablePA-cut(PA-FS,SRCA,RECVA,(PA-P1 :|: PA-P2),(PA-TO + PA-TD),T)
      or isEnablePA-reco-t(PA-FS,(PA-TO + PA-TD),T)
      or false .
    
  crl [release-unenable] :
    FP([T, (MSGCO from SRCA to RECVA), MSGQID, MSGFU], M)
    < msgloss : Injector | MLfaultRate : ML-R, MLvulnerableRl : ML-QL, MLvulnerableRecv : ML-AL, MLvulnerableSrc : ML-AL2, ML-AS >
    < msgdup : Injector | MDfaultRate : MD-R, MDvulnerableRl : MD-QL, MDvulnerableRecv : MD-AL, MDvulnerableSrc : MD-AL2, MD-AS >
    < partition : Injector | PAstatus : PA-FS, PAoccurTime : PA-TO, PAdurationTime : PA-TD, PApart : (PA-P1 :|: PA-P2), 
      PAallActors : PA-ALL, PAvulnerableRl : PA-QL, PAvulnerableRecv : PA-AL, PAvulnerableSrc : PA-AL2, PA-AS >
  =>
    < msgloss : Injector | MLfaultRate : ML-R, MLvulnerableRl : ML-QL, MLvulnerableRecv : ML-AL, MLvulnerableSrc : ML-AL2, ML-AS >
    < msgdup : Injector | MDfaultRate : MD-R, MDvulnerableRl : MD-QL, MDvulnerableRecv : MD-AL, MDvulnerableSrc : MD-AL2, MD-AS >
    < partition : Injector | PAstatus : PA-FS, PAoccurTime : PA-TO, PAdurationTime : PA-TD, PApart : (PA-P1 :|: PA-P2), 
      PAallActors : PA-ALL, PAvulnerableRl : PA-QL, PAvulnerableRecv : PA-AL, PAvulnerableSrc : PA-AL2, PA-AS >
    {T, (MSGCO from SRCA to RECVA)}
    if true
      and not isEnableML-vul(M,ML-R,MSGQID,ML-QL,SRCA,ML-AL2,RECVA,ML-AL)
      and not isEnableMD-vul(M,MD-R,MSGQID,MD-QL,SRCA,MD-AL2,RECVA,MD-AL,MSGFU) 
      and not isEnablePA-make-t(PA-FS,PA-TO,T)
      and not isEnablePA-make-rl(PA-FS,MSGQID,PA-QL,SRCA,PA-AL2,RECVA,PA-AL)
      and not isEnablePA-cut(PA-FS,SRCA,RECVA,(PA-P1 :|: PA-P2),(PA-TO + PA-TD),T)
      and not isEnablePA-reco-t(PA-FS,(PA-TO + PA-TD),T)
      and true .

  --- geneFaultRuleReadyList(FRNL,BL)
  --- generate a ready fault rule list, extract FRNL for according Bool in BL is true  
  op geneFaultRuleReadyList : FaultRuleNameList BoolList -> FaultRuleNameList [ctor] .
  var BL : BoolList . var B : Bool . var FRN : FaultRuleName . var FRNL : FaultRuleNameList .
  ceq geneFaultRuleReadyList((FRN :: FRNL),(B :: BL)) = FRN :: geneFaultRuleReadyList(FRNL,BL)
    if B [owise] .
  ceq geneFaultRuleReadyList((FRN :: FRNL),(B :: BL)) = geneFaultRuleReadyList(FRNL,BL)
    if not B [owise] .
  eq geneFaultRuleReadyList(nilFRNL,nilBL) = nilFRNL .

  --- generate faultEnable from FaultRuleNameList, indicating fault rule be selected
  op geneFaultEnable : FaultRuleNameList -> FaultFlag [ctor] .
  --- $geneFaultEnable(FaultRuleNameList,currentPri,highestScore,currentScore,FaultRuleName)
  op $geneFaultEnable : FaultRuleNameList Nat Float Float FaultRuleName -> FaultFlag [ctor] .
  eq geneFaultEnable(FRNL) = $geneFaultEnable(FRNL,999,0.0,rand,nullFRN) .
  var PRI : Nat . vars R1 R2 : Float . var FRN2 : FaultRuleName .
  --- high pri
  ceq $geneFaultEnable((FRN :: FRNL),PRI,R1,R2,FRN2) = $geneFaultEnable(FRNL,faultPriority(FRN),R1,rand,FRN)
    if faultPriority(FRN) < PRI .
  --- low pri
  ceq $geneFaultEnable((FRN :: FRNL),PRI,R1,R2,FRN2) = $geneFaultEnable(FRNL,PRI,R1,rand,FRN2)
    if faultPriority(FRN) > PRI .
  --- equal pri
  ceq $geneFaultEnable((FRN :: FRNL),PRI,R1,R2,FRN2) = $geneFaultEnable(FRNL,PRI,R1,rand,FRN2)
    if faultPriority(FRN) == PRI /\ R1 > R2 .
  ceq $geneFaultEnable((FRN :: FRNL),PRI,R1,R2,FRN2) = $geneFaultEnable(FRNL,PRI,R2,rand,FRN)
    if faultPriority(FRN) == PRI /\ R1 <= R2 .
  --- select fault rule
  eq $geneFaultEnable(nilFRNL,PRI,R1,R2,FRN) = faultEnable(FRN) [owise] .
endm

mod FAULT-LIB is 
  inc FAULT-COMBINE .
endm

--- mod FAULT-TRANS is 
---   inc FAULT-COMPOSITE .
  
---   var T : Float .
---   vars SRCO DSTO : Address .
---   var CON : Content .
---   vars M1 M2 M3 M4 M5 R1 R2 R31 R32 R41 R42 R5 : Float .
---   var ASFAULT : AttributeSet .
---   var MLVULCL : ContentList . var MLVULAL : AddressListF .
---   var PAFS : PAFaultStatus . vars PAAL11 PAAL22 : AddressListF .
---   var CRFS : CRFaultStatus . vars CrashOid : Address . var CRVCL : ContentList .
---   var ECAL : AddressListF . var ECECO : ContentEquivocatePairList .
---   var TPCTPL : ContentTemperingPairList . var TPAL : AddressListF .

---   crl [f-trans-ele]:
---     {T, (CON from SRCO to DSTO)}
---     < injector : Injector | 
---       MLmood : M1, MLfaultRate : R1, MLvulnerableContent : MLVULCL, MLvulnerableAddress : MLVULAL,
---       MDmood : M2, MDfaultRate : R2, 
---       PAmood : M3, PAstatus : PAFS, PApart : (PAAL11 :|: PAAL22), 
---         PAoccurTime : R31, PAdurationTime : R32,
---       CRmood : M4, CRstatus : CRFS, CRcrashingObj : CrashOid, CRvulnerableContent : CRVCL,
---         CRcrashRate : R41, CRrebootRate : R42,
---       DEmood : M5, DEfaultRate : R5,
---       ECevilSrc : ECAL, ECequivocateContent : ECECO,
---       TPevilSrc : TPAL, TPtemperContent : TPCTPL,
---       ASFAULT >
---     =>
---     < injector : Injector | 
---       MLmood : rand, MLfaultRate : R1, MLvulnerableContent : MLVULCL, MLvulnerableAddress : MLVULAL,
---       MDmood : rand, MDfaultRate : R2,
---       PAmood : rand, PAstatus : PAFS, PApart : (PAAL11 :|: PAAL22), 
---         PAoccurTime : R31, PAdurationTime : R32,
---       CRmood : rand, CRstatus : CRFS, CRcrashingObj : CrashOid, CRvulnerableContent : CRVCL,
---         CRcrashRate : R41, CRrebootRate : R42,
---       DEmood : rand, DEfaultRate : R5,
---       ECevilSrc : ECAL, ECequivocateContent : ECECO,
---       TPevilSrc : TPAL, TPtemperContent : TPCTPL,
---       ASFAULT >
---     if 
---       MLnotFault(M1,R1)
---       /\ MDnotFault(M2,R2)
---       /\ PAnotFault(PAFS,M3,R31,R31 + R32,T,DSTO,SRCO,PAAL11,PAAL22)
---       /\ CRnotFault(CRFS,M4,R41,R42,CrashOid,DSTO,CON,CRVCL)
---       /\ DEnotFault(M5,R5) 
---       /\ ECnotFault({T, (CON from SRCO to DSTO)},ECAL,ECECO) 
---       /\ TPnotFault({T, (CON from SRCO to DSTO)},TPAL,TPCTPL) .
--- endm