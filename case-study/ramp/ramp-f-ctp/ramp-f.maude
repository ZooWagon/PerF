*** fast RA reads
*** No read-write
*** No replication, i.e., #DC=1
*** with CTP
*** 2023.12.14 13:43

load ../input-modules/replica-table

mod RAMP-F is
  including CLIENT-REPLICA .
  including MESSAGE .
  including REPLICA-TABLE .
  including SAMPLER .
  including VERSION-RAMP .
  including VALUES-NAT .
  inc MSG-STRING-CONVERSION .
  inc APMAUDE .

  op ld : -> Delay .  --- local delay 
  op rd : -> Delay .  --- remote delay
  op nd : -> Delay .  --- no delay
  eq nd = 0.0 .
  op ctpd : -> Delay .  --- ctp timeout delay
  eq ctpd = 5.0 .

  --- lognormal distribution
  eq ld = sampleLogNormal(0.0,1.0) . --- miu, sigma 
  eq rd = sampleLogNormal(0.0,1.0) . 
---  eq rd = sampleLogNormal(0.0,1.0) * 100.0 .

  --- weibull distribution
---   eq ld = sampleWeibull(5.0,1.0) . 
---   eq rd = sampleWeibull(3.0,300.0) .

  --- or, ld = 0.0
  --- in our model, local delay seems to be local "processing" delay,
  --- which is negligible compared to the distributed data communication
  --- thus, the settings in our experiments could be:
---  eq ld = 0.0 .
---  eq rd = sampleLogNormal(0.0,1.0) .
--- eq rd = sampleWeibull(5.0,1.0) .

  vars RID TID RID' TID' TABLE M OID OID' A A' : Address .
  vars RIDS RIDS' TIDS : Addresses .
  vars AS AS' AS'' AS1 AS2 : AttributeSet .
  vars TXNS TXNS' : ConfigList .
  var K : Key .
  var X : LocalVar .
  var REPLICA-TABLE : ReplicaTable .
  vars OPS OPS' OPS'' : OperationList .
  vars V V' : Value .
  var WS : WriteSet .
  vars VARS VARS' : LocalVars .
  vars RS DS RS' WRITES WRITES' READS : Versions .
  vars LC VL VL' : KeyTimestamps .
  var VERSION : Version .
  vars TS TS' : Timestamp .
  vars MD MD' KS : KeySet .
  var VS : Versions .
***
  vars SQN SQN' : Float .
  var EXPR : Expression .
  var RT : KeyReplicas .
  vars 1STGETS 1STGETS' : 1stGets .
  vars 2NDGETS 2NDGETS' : 2ndGets .
  vars VSTS CMTS VSTS' CMTS' : VoteSites .
  vars T T1 T2 : Float .
  var FLAG : Bool .
  vars RECORD RECORD' : Record .
  var DR : DcReplicas .
  vars DC DC' : Address .
  var KR : KeyReplicas .
  vars RIDSS RIDSS' : AddressList .
  var CONT : Content .
  vars N N' : Nat .
  var SL : ScheduleList .

  ***************************
  *** RAMP-F with Clients ***
  ***************************

  ---??? simply consume "start" if no txn needs to start
  rl [receiving-start-when-no-txn-to-start] :
     < A : Client | gotTxns: emptyTxnList, AS >
     {T, start from A to A} {T | SL}
   =>
     < A : Client | gotTxns: emptyTxnList, AS > {T | SL} .

 crl [start-ro-or-rw-txn] :
     {T, start from A to A}  
     < M : Monitor | log: RECORD, AS2 >
     < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
     < A : Client | gotTxns: (< TID : Txn | operations: OPS,
											1stGetSites: 1STGETS, AS > ;; TXNS),
                    executing: noActor,
					dc: DC, AS' >
     {T | SL}
   =>
     < M : Monitor | log: (RECORD ; record(TID,T,0.0,empty,empty,false)), AS2 >
     < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
     < A : Client | gotTxns: TXNS,
                    executing: < TID : Txn | operations: OPS,
											 1stGetSites: (1STGETS ; 1st(TID,add1st(OPS,REPLICA-TABLE,DR,DC))), AS >,
					dc: DC, AS' >
     insertList({T | SL},genGets(A,TID,OPS,REPLICA-TABLE,DR,DC,T))
     if (not write-only(OPS)) .
	 
  op write-only : OperationList -> Bool .
  eq write-only((OPS (OID X :=read K) OPS')) = false .
  eq write-only(OPS) = true [owise] .
  
  *** sticky: to local datacenter replica  
  op add1st : OperationList ReplicaTable DcReplicas Address -> Addresses .
  eq add1st(((OID X :=read K) OPS),[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) =
       RID ; add1st(OPS,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) .
  eq add1st((write(OID,K,EXPR) OPS),[KR],DR,DC) = add1st(OPS,[KR],DR,DC) .
  eq add1st(nil,[KR],DR,DC) = nullAd .
  
  op genGets : Address Address OperationList ReplicaTable DcReplicas Address Float -> ScheduleList .
  eq genGets(A,TID,((OID X :=read K) OPS),[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T) = 
       genGets(A,TID,OPS,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T)
       ; [T + ld, get(TID,K,eptTS,DC,A) from A to RID, 0] .  
  eq genGets(A,TID,(write(OID,K,EXPR) OPS),[KR],DR,DC,T) =
       genGets(A,TID,OPS,[KR],DR,DC,T) .
  eq genGets(A,TID,nil,[KR],DR,DC,T) = nil .


  rl [receive-get] :
      < M : Monitor | concurReads: TIDS, AS2 >
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: VS,
                        latestCommit: LC, AS' >
      {T, get(TID,K,TS,DC,A) from A to RID}
      {T | SL}
    =>
      < M : Monitor | concurReads:  
	    (if TS == eptTS 
		   then TIDS 
		   else if $hasMapping(LC,K) 
		           then if LC[K] less-than TS
		                  then (TIDS ; TID) 
				          else TIDS fi
		           else if TS == ts(0,0.0)
		                  then TIDS
				          else (TIDS ; TID) fi fi fi), AS2 >		 
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: VS,
                        latestCommit: LC, AS' >
      if TS == eptTS
	    then insertList({T | SL},[T + ld, response1(TID,vmatch(K,VS,LC),RID) from RID to A,0])
	  	else insertList({T | SL},[T + ld, response2(TID,vmatch(K,VS,TS),RID) from RID to A,0])
	    fi .


  op inDC : Address Address DcReplicas -> Bool .
  eq inDC(RID,DC,(DR ; dc(DC,(RID ; RIDS)))) = true .
  eq inDC(RID,DC,DR) = false [owise] .
  
  
  op vmatch : Key Versions KeyTimestamps -> Version .
  op vmatch : Key Versions Timestamp -> Version .
  
  eq vmatch(K,(version(K,V,TS,MD),VS),(K |-> TS,LC)) = version(K,V,TS,MD) .
  eq vmatch(K,VS,LC) = version(K,[0],ts(0,0.0),empty) [owise] .  
  --- ??? deal with "K not in LC", namely, the first txn has reads
  eq vmatch(K,(version(K,V,TS,MD),VS),TS) = version(K,V,TS,MD) .
  eq vmatch(K,VS,TS) = version(K,[0],ts(0,0.0),empty) [owise] .  
  --- this should never apply since the 2nd-round read will fetch the version which has been prepared
  
  
  op _less-than_ : Timestamp Timestamp -> Bool .
  eq ts(RID,SQN) less-than ts(RID',SQN') =
          if SQN < SQN'
            then true
            else if SQN == SQN' and RID < RID'
                   then true
                   else false
                 fi
          fi .


 crl [receive-response1] :
     < M : Monitor | log: (RECORD ; record(TID,T1,0.0,READS,WRITES,false) ; RECORD'), AS2 >
     < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
     < A : Client | executing: < TID : Txn | operations: (OPS (OID X :=read K) OPS'),
                                             readSet: RS,
                                             localVars: VARS,
						                     1stGetSites: 1STGETS,
						                     2ndGetSites: 2NDGETS,
											 latest: VL, AS >, 
					dc: DC, AS' >
     {T, response1(TID,version(K,V,TS,MD),RID') from RID' to A}
     {T | SL}
   =>
     < M : Monitor | log: (RECORD ; record(TID,T1,0.0,(RS, version(K,V,TS,MD)),WRITES,false) ; RECORD'), AS2 >
     < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
     if 1STGETS'[TID] == nullAd
	   then < A : Client  | executing: < TID : Txn | operations: (OPS (OID X :=read K) OPS'),
                                              readSet: (RS, version(K,V,TS,MD)),
                                              localVars: insert(X,V,VARS),  --- useless for read-only txns
						                      1stGetSites: 1STGETS',
											  2ndGetSites: (2NDGETS ; 2nd(TID,RIDS)),
											  latest: lat(VL,MD,TS), AS >, 
							dc: DC, AS' >
            insertList({T | SL}, gen2ndGets(TID,lat(VL,MD,TS),(RS, version(K,V,TS,MD)),A,REPLICA-TABLE,DR,DC,T)
            ; [T + nd,commit-reads from A to A,0]	)		  
	   else < A : Client  | executing: < TID : Txn | operations: (OPS (OID X :=read K) OPS'),
                                             readSet: (RS, version(K,V,TS,MD)),
                                             localVars: insert(X,V,VARS),
						                     1stGetSites: 1STGETS',
											 2ndGetSites: 2NDGETS,
											 latest: lat(VL,MD,TS), AS >, 
							dc: DC, AS' >	{T | SL}
	 fi									
     if 1STGETS' := remove(TID,RID',1STGETS) /\
		RIDS := 2ndSites(lat(VL,MD,TS),(RS, version(K,V,TS,MD)),A,REPLICA-TABLE,DR,DC) .		


  op gen2ndGets : Address KeyTimestamps Versions Address ReplicaTable DcReplicas Address Float -> ScheduleList .  
  eq gen2ndGets(TID,(K |-> TS',VL),(version(K,V,TS,MD),RS),A,
  	 	[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T) 
   = gen2ndGets(TID,(K |-> TS',VL),RS,A,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T) ; 
       (if TS less-than TS'
         then [T + ld , get(TID,K,TS',DC,A) from A to RID,0]
		 else nil 
	   fi) .
  eq gen2ndGets(TID,VL,RS,A,REPLICA-TABLE,DR,DC,T) = nil [owise] .  --- if K is not in VL
  eq gen2ndGets(TID,VL,empty,A,REPLICA-TABLE,DR,DC,T) = nil .  


  op 2ndSites : KeyTimestamps Versions Address ReplicaTable DcReplicas Address -> Addresses .
  eq 2ndSites((K |-> TS',VL),(version(K,V,TS,MD),RS),A,
     	[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) 
   = 2ndSites((K |-> TS',VL),RS,A,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) ;
       (if TS less-than TS'
          then RID
          else nullAd
        fi) .
  eq 2ndSites(VL,RS,A,REPLICA-TABLE,DR,DC) = nullAd [owise] .  --- if K is not in VL
  eq 2ndSites(VL,empty,A,REPLICA-TABLE,DR,DC) = nullAd .  
 
	 
  op _[_] : 1stGets Address -> Addresses .
  eq (1st(TID,RIDS) ; 1STGETS)[TID] = RIDS . 
  
  op _[_] : 2ndGets Address -> Addresses .
  eq (2nd(TID,RIDS) ; 2NDGETS)[TID] = RIDS .
  
  op remove : Address Address 1stGets -> 1stGets .
  eq remove(TID,RID,(1st(TID,(RID ; RIDS)) ; 1STGETS)) =
       1st(TID,RIDS) ; 1STGETS .
  eq remove(TID,RID,1STGETS) = 1STGETS [owise] .
  
  op remove : Address Address 2ndGets -> 2ndGets .
  eq remove(TID,RID,(2nd(TID,(RID ; RIDS)) ; 2NDGETS)) =
       2nd(TID,RIDS) ; 2NDGETS .
  eq remove(TID,RID,2NDGETS) = 2NDGETS [owise] .
  

  op lat : KeyTimestamps KeySet Timestamp -> KeyTimestamps .
  eq lat(VL,(K,MD),TS) = lat(insert(K,maxts(VL,K,TS),VL),MD,TS) .
  eq lat(VL,empty,TS) = VL .
	

  op maxts : KeyTimestamps Key Timestamp -> Timestamp .
  eq maxts(LC,K,TS) = if $hasMapping(LC,K)
                        then if LC[K] less-than TS
                               then TS
                               else LC[K]
                             fi
                        else TS
                      fi .
				
					  
  rl [receive-response2] :
     < M : Monitor | log: (RECORD ; record(TID,T1,0.0,(READS,version(K,V',TS',MD')),WRITES,false) ; RECORD'), AS2 >
     < A : Client | executing: < TID : Txn | operations: (OPS (OID X :=read K) OPS'),
                                             readSet: (RS,version(K,V',TS',MD')),
                                             localVars: VARS,
								     		 2ndGetSites: 2NDGETS, AS >, AS' >
     {T, response2(TID,version(K,V,TS,MD),RID') from RID' to A}
     {T | SL}
   => 
     < M : Monitor | log: (RECORD ; record(TID,T1,0.0,(READS,version(K,V,TS,MD)),WRITES,false) ; RECORD'), AS2 >   
     < A : Client | executing: < TID : Txn | operations: (OPS (OID X :=read K) OPS'),
                                             readSet: (RS,version(K,V,TS,MD)),
                                             localVars: insert(X,V,VARS),
								 			 2ndGetSites: remove(TID,RID',2NDGETS), AS >, AS' >
     insertList({T | SL},[T + nd, commit-reads from A to A,0]) .
		
  --- only consider read-only here!
 crl [commit-reads] :
     {T, commit-reads from A to A} {T | SL}
     < M : Monitor | log: (RECORD ; record(TID,T1,0.0,READS,WRITES,false) ; RECORD'), AS2 > 
     < A : Client | executing: < TID : Txn | 1stGetSites: 1STGETS,
						                     2ndGetSites: 2NDGETS, AS >,
                    committed: TXNS, AS' >
   =>
     < M : Monitor | log: (RECORD ; record(TID,T1,T,READS,WRITES,true) ; RECORD'), AS2 >
     < A : Client | executing: noActor,
                    committed: (TXNS ;; < TID : Txn | 1stGetSites: 1STGETS,
			   	                                      2ndGetSites: 2NDGETS, AS >), AS' >
     insertList({T | SL},[T + nd, start from A to A,0])  ---??? "start"
     if 1STGETS[TID] == nullAd /\
        2NDGETS[TID] == nullAd .
		
		
 crl [not-ready-to-commit-reads] :
     {T, commit-reads from A to A}
     < A : Client | executing: < TID : Txn | 1stGetSites: 1STGETS,
                                             2ndGetSites: 2NDGETS, AS >, AS' >
  =>
    < A : Client | executing: < TID : Txn | 1stGetSites: 1STGETS,
                                            2ndGetSites: 2NDGETS, AS >, AS' >
    if 1STGETS[TID] =/= nullAd or
       2NDGETS[TID] =/= nullAd .
	  

  *** reads finish!!
  *** writes start from here!

  crl [start-wo-txn] :
      {T, start from A to A}  {T | SL}
      < M : Monitor | log: RECORD, AS2 >
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < A : Client | gotTxns: (< TID : Txn | operations: OPS,
                                             localVars: VARS, 
 										     txnSqn: SQN, 
 											 voteSites: VSTS, AS > ;; TXNS),
                     executing: noActor,
 	        		 dc: DC, AS' >
    =>
      < M : Monitor | log: (RECORD ; record(TID,T,0.0,empty,WRITES,false)), AS2 >
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < A : Client | gotTxns: TXNS,
                     executing: < TID : Txn | operations: OPS,
                                              localVars: VARS,
 											  txnSqn: T,
 											  voteSites: (VSTS ; voteSites(TID,addVotes(OPS,REPLICA-TABLE,DR,DC))), AS >,
 	    			 dc: DC, AS' >
      insertList({T | SL},genPuts(A,TID,OPS,T,VARS,REPLICA-TABLE,DR,DC))
      if write-only(OPS) /\
         WRITES := ws(OPS,A,T,VARS) .

   op addVotes : OperationList ReplicaTable DcReplicas Address -> Addresses .
   eq addVotes((write(OID,K,EXPR) OPS),[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) =
        RID ; addVotes(OPS,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC) .
   eq addVotes(((OID X :=read K) OPS),[KR],DR,DC) = addVotes(OPS,[KR],DR,DC) .
   eq addVotes(nil,[KR],DR,DC) = nullAd .  
  
   op genPuts : Address Address OperationList Float LocalVars ReplicaTable DcReplicas Address -> ScheduleList .	
   op $genPuts : Address Address OperationList Float LocalVars ReplicaTable DcReplicas Address OperationList -> ScheduleList .	
   eq genPuts(A,TID,OPS,SQN,VARS,[KR],DR,DC) = $genPuts(A,TID,OPS,SQN,VARS,[KR],DR,DC,OPS) .
   eq $genPuts(A,TID,(write(OID,K,EXPR) OPS),SQN,VARS,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,(OPS' write(OID,K,EXPR) OPS'')) =
        $genPuts(A,TID,OPS,SQN,VARS,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,(OPS' write(OID,K,EXPR) OPS'')) ; 
        [SQN + ld, prepare(TID,version(K,eval(EXPR,VARS),ts(A,SQN),md(OPS' OPS'')),DC,A) from A to RID, 0] .
   eq $genPuts(A,TID,((OID X :=read K) OPS),SQN,VARS,[KR],DR,DC,OPS') =
        $genPuts(A,TID,OPS,SQN,VARS,[KR],DR,DC,OPS') .
   eq $genPuts(A,TID,nil,SQN,VARS,[KR],DR,DC,OPS') = nil .
  
   op ws : OperationList Address Float LocalVars -> Versions .
   op $ws : OperationList Address Float LocalVars OperationList -> Versions .
   eq ws(OPS,RID,SQN,VARS) = $ws(OPS,RID,SQN,VARS,OPS) .
   eq $ws((write(OID,K,EXPR) OPS),RID,SQN,VARS,(OPS' write(OID,K,EXPR) OPS'')) = 
        version(K,eval(EXPR,VARS),ts(RID,SQN),md(OPS' OPS'')), 
        $ws(OPS,RID,SQN,VARS,(OPS' write(OID,K,EXPR) OPS'')) .
   eq $ws(((OID X :=read K) OPS),RID,SQN,VARS,OPS') =
        $ws(OPS,RID,SQN,VARS,OPS') .
   eq $ws(nil,RID,SQN,VARS,OPS') = empty .	
  
   op md : OperationList -> KeySet .
   eq md((write(OID,K,EXPR) OPS)) = K, md(OPS) .
   eq md(((OID X :=read K) OPS)) = md(OPS) .
   eq md(nil) = empty .	 
   
   --- CTP
   rl [receive-prepare] :
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: VS, AS' >
      {T, prepare(TID,VERSION,DC,A) from A to RID} {T | SL}
    =>
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: (VS,VERSION), AS' >
      insertList({T | SL},([T + ld, prepare-reply(TID,true,RID) from RID to A, 0] 
                         ; [T + ctpd, ctp-timeout(TID) from RID to RID, 0])) .

  crl [receive-prepare-reply] :
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < A : Client | executing: < TID : Txn | operations: OPS,
 	                                         txnSqn: SQN,
 											 voteSites: VSTS,
 											 commitSites: CMTS, AS >,
 					dc: DC, AS' >
      {T, prepare-reply(TID,FLAG,RID') from RID' to A} {T | SL}  --- FLAG is always true in RAMP
    =>
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      if VSTS'[TID] == nullAd  --- all votes received
        then < A : Client | executing: < TID : Txn | operations: OPS,
 	                                                txnSqn: SQN,
 						                            voteSites: noVS,
 						                            commitSites: (CMTS ; voteSites(TID,addVotes(OPS,REPLICA-TABLE,DR,DC))), AS >,
 						   dc: DC, AS' >
             insertList({T | SL},genCommits(A,TID,OPS,SQN,REPLICA-TABLE,DR,DC,T))
        else < A : Client | executing: < TID : Txn | operations: OPS,
 	                                                txnSqn: SQN,
 						                            voteSites: VSTS',
 						                            commitSites: CMTS, AS >,                    
 						   dc: DC, AS' > {T | SL}
      fi 
    if VSTS' := remove(TID,RID',VSTS) .
   

   op _[_] : VoteSites Address -> Addresses .
   eq (voteSites(TID,RIDS) ; VSTS)[TID] = RIDS . 

   op remove : Address Address VoteSites -> VoteSites .
   eq remove(TID,RID,(voteSites(TID,(RID ; RIDS)) ; VSTS)) =
        voteSites(TID,RIDS) ; VSTS .
   eq remove(TID,RID,VSTS) = VSTS [owise] .
  
   op genCommits : Address Address OperationList Float ReplicaTable DcReplicas Address Float -> ScheduleList .
   eq genCommits(A,TID,(write(OID,K,EXPR) OPS),SQN,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T) =
        genCommits(A,TID,OPS,SQN,[replicatingSites(K,(RIDSS ;; RID ;; RIDSS')) ;; KR],(DR ; dc(DC,(RID ; RIDS))),DC,T) ;
        [T + ld , commit(TID,ts(A,SQN),DC,A) from A to RID,0] .
   eq genCommits(A,TID,((OID X :=read K) OPS),SQN,[KR],DR,DC,T) = genCommits(A,TID,OPS,SQN,[KR],DR,DC,T) .
   eq genCommits(A,TID,nil,SQN,[KR],DR,DC,T) = nil .

   --- CTP. Replica record some info
   rl [receive-commit] :
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: VS,
                        latestCommit: LC,
                        latestCommitCont: CONT, 
                        queryAddr: null, AS' >
      {T, commit(TID,ts(A',SQN),DC,A) from A to RID} {T | SL}
    =>
      < TABLE : Table | datacenter: DR, AS >
      < RID : Replica | datastore: VS,
                        latestCommit: cmt(LC,VS,ts(A,SQN)),
                        latestCommitCont: commit(TID,ts(A',SQN),DC,A), 
                        queryAddr: null, AS' >
      insertList({T | SL},[T + ld, committed(TID,RID) from RID to A',0]) .
	 
	 
   op cmt : KeyTimestamps Versions Timestamp -> KeyTimestamps .
   eq cmt(LC,VS,TS) = $cmt(LC,keyFilter(VS,TS),TS) .
   op $cmt : KeyTimestamps KeySet Timestamp -> KeyTimestamps .
   eq $cmt(LC,(K,KS),TS) = $cmt(insert(K,maxts(LC,K,TS),LC),KS,TS) .
   eq $cmt(LC,empty,TS) = LC .
  
   op keyFilter : Versions Timestamp -> KeySet . 
   eq keyFilter((version(K,V,TS,MD),VS),TS) = K, keyFilter(VS,TS) .
   eq keyFilter(VS,TS) = empty [owise] .

   op maxts : KeyTimestamps Key Timestamp -> Timestamp .
   eq maxts(LC,K,TS) = if $hasMapping(LC,K)
                            then if LC[K] less-than TS
                                   then TS
                                   else LC[K]
                                 fi
                            else TS
                          fi . 

  crl [receive-committed-1] :
      < M : Monitor | log: (RECORD ; record(TID,T1,0.0,READS,WRITES,false) ; RECORD'), AS2 >
 	  < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < A : Client | executing: < TID : Txn | commitSites: CMTS, AS >,
                     committed: TXNS, AS' >
      {T, committed(TID,RID') from RID' to A} {T | SL}
    =>
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < M : Monitor | log: (RECORD ; record(TID,T1,T,READS,WRITES,true) ; RECORD'), AS2 >
      < A : Client | executing: noActor,
                    committed: (TXNS ;; < TID : Txn | commitSites: CMTS', AS >), AS' >
      insertList({T | SL},[T + nd, start from A to A,0])  
      if CMTS' := remove(TID,RID',CMTS) /\ CMTS'[TID] == nullAd .

  crl [receive-committed-2] :
      < M : Monitor | log: (RECORD ; record(TID,T1,0.0,READS,WRITES,false) ; RECORD'), AS2 >
 	  < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < A : Client | executing: < TID : Txn | commitSites: CMTS, AS >,
                     committed: TXNS, AS' >
      {T, committed(TID,RID') from RID' to A} {T | SL}
    =>
      < TABLE : Table | table: REPLICA-TABLE, datacenter: DR, AS1 >
      < M : Monitor | log: (RECORD ; record(TID,T1,0.0,READS,WRITES,false) ; RECORD'), AS2 >
      < A : Client | executing: < TID : Txn | commitSites: CMTS', AS >,
                    committed: TXNS, AS' > {T | SL}
      if CMTS' := remove(TID,RID',CMTS) /\ CMTS'[TID] =/= nullAd .

  --- CTP starts here !
  crl [ctp-trigger] : 
    {T, ctp-timeout(TID) from RID to RID} {T | SL}
    < RID : Replica | latestCommitCont: commit(TID',ts(A',SQN),DC,A), AS >
  =>
    < RID : Replica | latestCommitCont: commit(TID',ts(A',SQN),DC,A), AS >
    insertList({T | SL},[T + ld, ctp-query(TID) from RID to sd(RID,1), 0]) 
  if isTIDlessthan(TID',TID) .

  crl [ctp-no-need] : 
    {T, ctp-timeout(TID) from RID to RID} {T | SL}
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), AS >
  =>
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), AS >
    {T | SL}
  if not isTIDlessthan(TID',TID) .
  
  --- isTIDlessthan(A,B), return A < B
  op isTIDlessthan : Address Address -> Bool .
  ceq isTIDlessthan(N . TID, N' . TID') = N < N' if N =/= N' .
  ceq isTIDlessthan(N . TID, N' . TID') = isTIDlessthan(TID,TID') if N == N' .
  eq isTIDlessthan(N,N') = N < N' .

  --- clean the ctp-query msg which dest is 0
  rl [ctp-clean-1] :
    {T, ctp-query(TID) from RID' to 0} {T | SL}
  =>
    {T | SL} .
  --- clean the ctp-query msg if it's first txn
  rl [ctp-clean-2] :
    {T, ctp-timeout(TID) from RID to RID} {T | SL}
    < RID : Replica | latestCommitCont: nullCONT, AS >
  =>
    < RID : Replica | latestCommitCont: nullCONT, AS >
    {T | SL} .
  --- clean the ctp-query msg if it's old
  crl [ctp-clean-3] :
    {T, ctp-query(TID) from RID' to RID} {T | SL}
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), AS >
  =>
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), AS >
    {T | SL}
  if isTIDlessthan(TID,TID') .
  --- clean the redundant committed
  rl [ctp-clean-4] :
    < A : Client | committed: (TXNS ;; < TID : Txn | AS > ;; TXNS'), AS' >
    {T, committed(TID,RID') from RID' to A} {T | SL}
  =>
    < A : Client | committed: (TXNS ;; < TID : Txn | AS > ;; TXNS'), AS' >
    {T | SL} .

  rl [ctp-reply] :
    {T, ctp-query(TID) from RID' to RID} {T | SL}
    < RID : Replica | latestCommitCont: commit(TID,ts(A,SQN),DC,A), AS >
  =>
    < RID : Replica | latestCommitCont: commit(TID,ts(A,SQN),DC,A), AS >
    insertList({T | SL}, [T + ld, commit(TID,ts(A,SQN),DC,RID) from RID to RID',0]) .

  crl [ctp-store-reply-later] :
    {T, ctp-query(TID) from RID' to RID} {T | SL}
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), queryAddr: null, AS >
  =>
    < RID : Replica | latestCommitCont: commit(TID',ts(A,SQN),DC,A), queryAddr: RID', AS >
    {T | SL}
  if isTIDlessthan(TID',TID) .

  --- CTP. recv commit and reply ctp-query
  crl [ctp-receive-commit] :
    < TABLE : Table | datacenter: DR, AS >
    < RID : Replica | datastore: VS,
                      latestCommit: LC,
                      latestCommitCont: CONT, 
                      queryAddr: RID', AS' >
    {T, commit(TID,ts(A,SQN),DC,A) from A to RID} {T | SL}
  =>
    < TABLE : Table | datacenter: DR, AS >
    < RID : Replica | datastore: VS,
                      latestCommit: cmt(LC,VS,ts(A,SQN)),
                      latestCommitCont: commit(TID,ts(A,SQN),DC,A), 
                      queryAddr: null, AS' >
    insertList({T | SL},[T + ld, committed(TID,RID) from RID to A,0] ; 
                        [T + ld, commit(TID,ts(A,SQN),DC,RID) from RID to RID',0]) 
  if RID' =/= null .
  

endm
