---(
revised apmaude, zzw
add AddressSetF and AddressListF for fauli-lib
2023.12.27 14:32
)
set show advisories off .

fmod TERM-ORDER{X :: TRIV} is
  protecting EXT-BOOL .
  protecting CONVERSION .
  protecting META-LEVEL .

  vars E F : [X$Elt] .
  vars Q P : Qid .
  vars A B : NeTermList .
  vars C D : TermList .
  vars T U : Term .

  op lt : [X$Elt] [X$Elt] -> Bool .
  eq lt(E, F) = $lt(upTerm(E), upTerm(F)) .
  
  op $lt : TermList TermList -> Bool .
  eq $lt(Q, P) = string(Q) < string(P) .
  eq $lt(Q[A], P) = $lt(Q, P) .
  eq $lt(Q, P[B]) = $lt(Q, P) or-else Q == P .
  eq $lt(Q[A], P[B]) =
    if Q == P then $lt(A, B)
    else $lt(Q, P)
    fi .
  eq $lt(empty, B) = true .
  eq $lt(C, empty) = false .
  eq $lt((T, C), (U, D)) =
    if T == U then $lt(C, D)
    else $lt(T, U)
    fi .
endfm

fmod ADDRESS is
  pr NAT .

  sort Address .
  subsort Nat < Address .

  op null : -> Address .
  op nullAddr : -> Address [ctor] .

  --- Address are composed of sequences of natural numbers
  op _._ : Address Address -> Address [assoc prec 10] .
  op _<_ : Address Address -> Bool [ditto] .

  vars N1 N2 N M : Nat .
  vars AD1 AD2 A : Address .

  eq N1 . AD1 < N2 . AD2 = if N1 == N2 then AD1 < AD2 else N1 < N2 fi .
  eq N1 < N2 . AD2 = if N1 == N2 then true else N1 < N2 fi .
  eq N1 . AD1 < N2 = if N1 == N2 then false else N1 < N2 fi .

  --- set of Address for fault-lib, by zzw
  sort AddressSetF .
  subsort Address < AddressSetF .
  op nullASF : -> AddressSetF .
  op _^;^_ : AddressSetF AddressSetF -> AddressSetF [ctor assoc comm id: nullASF] .

  --- list of Address for fault-lib, by zzw
  sort AddressListF .
  subsort Address < AddressListF .
  op nilALF : -> AddressListF [ctor] .
  op _^:^_ : AddressListF AddressListF -> AddressListF [ctor assoc id: nilALF] .

endfm
view Address from TRIV to ADDRESS is sort Elt to Address . endv

fmod ACTOR-MODEL is
  pr ADDRESS + FLOAT .

  --- ActorConfig represents a soup of actors containing no messages
  sorts Actor Config ActorConfig .  
  sorts Msg ScheduleMsg ActiveMsg .
  sorts ActorType Attribute AttributeSet Content .

  subsorts ScheduleMsg ActiveMsg < Config .
  subsort Actor < ActorConfig < Config .
  subsort Attribute < AttributeSet .

  op null : -> ActorConfig .
  op __ : ActorConfig ActorConfig -> ActorConfig [assoc comm id: null] .
  op __ : Config Config -> Config [assoc comm id: null] .

  --- Messages:
  op [_,_,_] : Float Msg Nat -> ScheduleMsg .  --- drop?
  op {_,_} : Float Msg -> ActiveMsg .

  op nullCONT : -> Content .
  op _from_to_ : Content Address Address -> Msg .
  op _to_      : Content Address         -> Msg .

  --- Actors:
  op <_:_|_> : Address ActorType AttributeSet -> Actor [format (ni d d d d d d d)] .
  op noActor : -> Actor .

  --- Attributes can be used to add user defined data to an actor
  op mt : -> AttributeSet .
  op _,_ : AttributeSet AttributeSet -> AttributeSet [assoc comm id: mt] .
endfm
view Order from TRIV to ACTOR-MODEL is sort Elt to Msg . endv

--- for delay msg, by zzw
load probability

mod SCHEDULER is
  pr ACTOR-MODEL .
  pr TERM-ORDER{Order} .

  sorts Scheduler ScheduleList .
  subsort Scheduler < Config .
  subsort ScheduleMsg < ScheduleList .

  op  nil : -> ScheduleList .
  op  _;_ : ScheduleList ScheduleList -> ScheduleList [assoc id: nil format(d d n d)] .

  op {_|_} : Float ScheduleList -> Scheduler [format (n d d n d d)] .
  op insert : Scheduler ScheduleMsg -> Scheduler .
  op insert : ScheduleList ScheduleMsg -> ScheduleList .
  op insertList : Scheduler ScheduleList -> Scheduler .
  op insertList : ScheduleList ScheduleList -> ScheduleList .

  --- Emit a message, perform a rule, ad nauseam, until time-limit
  op run : Config Float -> Config .
  op step : Config -> Config [iter] .


  vars gt LIMIT : Float .
  vars t1 t2 : Float .
  vars SL SL' : ScheduleList .
  vars M1 M2 : Msg .
  var S : Scheduler .
  var C : Config .
  vars A A' A1 A2 : Address .
  var T : ActorType .
  var AS : AttributeSet .
  var CO : Content .
  var AC : ActorConfig .
  var SM : ScheduleMsg .
  var AM : ActiveMsg .
  var P : Nat .

  eq insert({ gt | SL }, [ t1 , M1, 0 ]) =
    {gt | insert(SL,[ gt + t1 , M1, 0 ] ) } .
  eq insert([ t1 , M1, 0 ] ; SL , [ t2 , M2, 0 ]) =
    if (t1 < t2) or ((t1 == t2)) and lt(M1,M2) then
      [ t1 , M1, 0 ] ; insert(SL, [ t2 , M2, 0 ])
    else
      ([ t2 , M2, 0 ] ; [ t1 , M1, 0 ] ; SL)
    fi .
  eq insert(nil , [ t2 , M2, 0 ]) = [ t2 , M2, 0 ] .

  eq insertList({gt | SL }, SL') = {gt | insertList(SL, SL') } .
  eq insertList(SL , [ t2 , M2, 0 ] ; SL') = insertList( insert(SL, [ t2, M2, 0 ]), SL' ) .
  eq insertList(SL , nil ) = SL .

  --- insert a schedule msg to the scheduler 
  eq [ t1, M1, 0 ] S = insert(S, [ t1, M1, 0 ]) .
  eq [ t1, M1, P ] S = S [owise] .


  eq step(AC {gt | [ t1 , M1, 0 ] ; SL}) =
       { t1 , M1 } AC {t1 | SL} .
  
  
  --- finish before limit
  ---(
  eq run(AC {gt | SL}, LIMIT) =
    if (gt <= LIMIT and SL =/= nil) then
      run(step(AC {gt | SL}), LIMIT)
    else
      AC {gt | SL}
    fi .
  )


  --- eagerness
 ceq run(AC {gt | SL}, LIMIT) =
    (if (gt <= LIMIT and SL =/= nil) then
      run(step(AC {gt | SL}), LIMIT)
    else
      AC {gt | SL}
    fi)
    if not eagerEnabled(AC) .
  
  op eagerEnabled : ActorConfig -> Bool .
  eq eagerEnabled(AC) = false [owise] .
  
  --- Len of AddressSetF and AddressListF
  var O : Address . var ASF : AddressSetF . var ALF : AddressListF .
  op len : AddressSetF -> Nat .
  eq len(nullASF) = 0 .
  eq len(O ^;^ ASF) = 1 + len(ASF) [owise] .
  op len : AddressListF -> Nat .
  eq len(nilALF) = 0 .
  eq len(O ^:^ ALF) = 1 + len(ALF) [owise] .

  --- Propagate Msgs, by zzw, deprecated
  var O' : Address . var MSG : Msg .
  op propagate_from_to_at_ : Content Address AddressSetF Float -> ScheduleList . 
  ceq propagate CO from O' to (O ^;^ ASF) at t1 = 
    delay-msg((CO from O' to O),t1) ;
    (propagate CO from O' to ASF at t1) if O =/= null [owise] .
  eq propagate CO from O' to nullASF at t1 = nil .

  --- Delay msg, need probability, by zzw
  pr PROBABILITY .
  op delay-msg : Msg Float -> ScheduleMsg [ctor] .
  eq delay-msg(MSG, t1) = [t1 + lognormal(0.0,1.0,rand), MSG, 0] .

endm


mod APMAUDE is
  pr SCHEDULER .

  --- Operations supported by PVeStA
  op initState : -> Config .
  op sat : Nat Config -> Bool .
  op val : Nat Config -> Float .
  op tick : Config -> Config .
  op getTime : Config -> Float .
  op LIMIT : -> Float .

  var C : Config .
  var gt : Float .
  var SL : ScheduleList .

  eq tick(C) = run(C, 500.0) .
  eq getTime(C {gt | SL}) =  gt .
endm